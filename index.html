<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <head>
        <script src="https://d3js.org/d3.v3.min.js"></script>
        <script type="text/javascript" src="d3-grid.js"></script>
    </head>
    <title>Covid19 Visualization</title>
    <body>
    <label for="rate">Infection Rate (between 0% to 100 %)</label>
    <input type="text" id="rate">
    <br/>
    <button onclick="startSimulation()">Start Simulation</button>
    </body>
</head>
<body>

<script>
function startSimulation() {
    var percent_rate = document.getElementById("rate").value;
    let cur_infections = 100;
    let infection_rate = 1 + (percent_rate / 100)
    console.log("infection rate is " + infection_rate);
    let max_radius = 50;
    let population = 100000;
    //assuming num_neighborhoods is a perfect square
    let num_neighborhoods = 400;
    let pop_per_neighborhood = population / num_neighborhoods;
    console.log("population per neighborhood is " + pop_per_neighborhood);
    let rows_cols = Math.sqrt(num_neighborhoods);

    //represents the number of infections in each neighborhood
    var infections_in_neighborhoods = distribute(num_neighborhoods, cur_infections);
    console.log(infections_in_neighborhoods);
    var points = [];
    //current set of points that have been infected to the max.
    var full_points = new Set();
    //current set of non-full points
    var cur_points = new Set();

    //dimensions of the grid, assumed to be a square.
    var gridSize = rows_cols * max_radius;
    //grid dimensions
    var pointGrid = d3.layout.grid()
        .points()
        .size([gridSize, gridSize])
        .rows([rows_cols])
        .cols([rows_cols]);

    //svg dimensions
    var width = gridSize * 2,
        height = gridSize * 2;
    var svg = d3.select("body").append("svg")
        .attr({
            width: width,
            height: height
        })
        .append("g")
        .attr("transform", "translate(70,70)");
    //10 by 10 grid means 100 points
    //start off with 100 points
    for (var i = 0; i < infections_in_neighborhoods.length; i++) {
        var radius = infections_in_neighborhoods[i] / pop_per_neighborhood * max_radius;
        addPoint(radius);
    }
    cur_points = new Set(points);


    var tick = setInterval(update, 100);


    //push represents one day of growth
    // function push() {
    //     if (points.length >= 250) {
    //         clearInterval(tick);
    //         return;
    //     }
    //     let new_length = infection_rate * points.length;
    //     let num_new_points = new_length - points.length;
    //     for (let i = 0; i < num_new_points; ++i) {
    //         addPoint();
    //     }
    // }

    function addPoint(radius) {
        points.push({});
        var point = svg.selectAll(".point")
            .data(pointGrid(points));
        point.enter().append("circle")
            .attr("class", "point")
            .attr("r", radius)
            .attr("transform", function (d) {
                return "translate(" + d.x + "," + d.y + ")";
            });

    }

    function update() {
        //check if everyone has been infected
        if (cur_infections >= population) {
            clearInterval(tick);
            return;
        }
        let num_new_infections = infection_rate * cur_infections - cur_infections;
        // console.log("num new infections is " + num_new_infections)
        // //update current number of infections
        // console.log("cur infections was " + cur_infections);
        cur_infections = cur_infections + num_new_infections;
        // console.log("cur infections is now " + cur_infections);

        let new_infections_array = distribute(num_neighborhoods, num_new_infections);
        console.log(new_infections_array);
        infections_in_neighborhoods = infections_in_neighborhoods.map(function (num, idx) {
            return num + new_infections_array[idx];
        });
        console.log(infections_in_neighborhoods);
        //make this select some
        var point = svg.selectAll(".point")
            .data(pointGrid(points));

        point.each(function (d, i) {
            var cur_radius = d3.select(this).attr("r");
            var this_neighborhood_infections = infections_in_neighborhoods[i];
            var new_radius = Math.min(max_radius, (this_neighborhood_infections / pop_per_neighborhood) * max_radius);
            if (new_radius !== cur_radius) {
                d3.select(this).transition().attr("r", new_radius);
            }
        })
        //need to get previous radius and multiply by factor related to new infections
        // point.transition()
        //     .attr("r", max_radius)
    }

    /**
     * distributes value into array of length length
     * @param length of array to be distributed to
     * @param value to distribute
     * @returns array of length length that sums up to value
     */
    function distribute(length, value) {
        if (length <= 1)
            return [value];
        var half = Math.floor(length / 2),
            dist = Math.floor(Math.random() * value);
        return distribute(half, dist).concat(distribute(length - half, value - dist));
    }
}

</script>
</body>
</html>