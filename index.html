<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <head>
        <script src="https://d3js.org/d3.v3.min.js"></script>
        <script type="text/javascript" src="d3-grid.js"></script>
    </head>
    <title>Covid19 Visualization</title>
    <body>
    <label for="rate">Infection Rate (between 0% to 100 %)</label>
    <input type="text" id="rate">
    <br/>
    <button onclick="startSimulation()">Start Simulation</button>
    </body>
</head>
<body>

<script>
function startSimulation() {
    var percent_rate = document.getElementById("rate").value;
    let cur_infections = 100;
    let infection_rate = 1 + (percent_rate / 100)
    console.log("infection rate is " + infection_rate);
    let max_radius = 50;
    let population = 100000;
    //assuming num_neighborhoods is a perfect square
    let num_neighborhoods = 400;
    let neighborhood_populations = distribute_population(10, 400);
    let rows_cols = Math.sqrt(num_neighborhoods);

    //represents the number of infections in each neighborhood
    var infections_in_neighborhoods = distribute_add(Array(num_neighborhoods).fill(0), cur_infections);
    var points = [];

    //dimensions of the grid, assumed to be a square.
    var gridSize = rows_cols * max_radius;
    //grid dimensions
    var pointGrid = d3.layout.grid()
        .points()
        .size([gridSize, gridSize])
        .rows([rows_cols])
        .cols([rows_cols]);

    //svg dimensions
    var width = gridSize * 2,
        height = gridSize * 2;
    var svg = d3.select("body").append("svg")
        .attr({
            width: width,
            height: height
        })
        .append("g")
        .attr("transform", "translate(70,70)");
    //10 by 10 grid means 100 points
    //start off with 100 points
    for (var i = 0; i < infections_in_neighborhoods.length; i++) {
        var radius = infections_in_neighborhoods[i] / neighborhood_populations[i] * max_radius;
        addPoint(radius);
    }


    var tick = setInterval(update, 100);


    //push represents one day of growth
    // function push() {
    //     if (points.length >= 250) {
    //         clearInterval(tick);
    //         return;
    //     }
    //     let new_length = infection_rate * points.length;
    //     let num_new_points = new_length - points.length;
    //     for (let i = 0; i < num_new_points; ++i) {
    //         addPoint();
    //     }
    // }

    function addPoint(radius) {
        points.push({});
        var point = svg.selectAll(".point")
            .data(pointGrid(points));
        point.enter().append("circle")
            .attr("class", "point")
            .attr("r", radius)
            .attr("transform", function (d) {
                return "translate(" + d.x + "," + d.y + ")";
            });

    }

    function update() {
        //check if everyone has been infected
        if (cur_infections >= population) {
            clearInterval(tick);
            return;
        }
        let num_new_infections = infection_rate * cur_infections - cur_infections;
        // console.log("num new infections is " + num_new_infections)
        // //update current number of infections
        // console.log("cur infections was " + cur_infections);
        cur_infections = cur_infections + num_new_infections;
        // console.log("cur infections is now " + cur_infections);

        infections_in_neighborhoods = distribute_add(infections_in_neighborhoods, num_new_infections);

        //make this select some
        var point = svg.selectAll(".point")
            .data(pointGrid(points));

        point.each(function (d, i) {
            var cur_radius = d3.select(this).attr("r");
            var this_neighborhood_infections = infections_in_neighborhoods[i];
            var new_radius = Math.min(max_radius, (this_neighborhood_infections / neighborhood_populations[i]) * max_radius);
            if (new_radius !== cur_radius) {
                d3.select(this).transition().attr("r", new_radius);
            }
        })

    }

    /**
     * distributes value into array of length length
     * @param value to distribute
     * @return array of length length with randomly distributed value
     */
    function distribute(length, value) {
        if (length <= 1)
            return [value];
        var half = Math.floor(length / 2),
            dist = Math.floor(Math.random() * value);
        return distribute(half, dist).concat(distribute(length-half, value-dist));
    }

    /**
     * distributes value to array
     */
    function distribute_add(array, value) {
        var to_be_added = distribute(array.length, value);
        return array.map(function (num, idx) {
            return num + to_be_added[idx];
        });
    }

    /**
     * Distributes population to neighborhoods
     */
    function distribute_population(min, max) {
        if (min * num_neighborhoods > population) {
            throw new Error("minimum neighborhood population too high");
        } else if (max * num_neighborhoods < population) {
            throw new Error("maximum neighborhood population too low");
        } else if (min > max) {
            throw new Error("min neighborhood population can't be greater than max");
        }
        var neighborhoods = Array(num_neighborhoods).fill(min);
        var pop_to_be_filled = population - num_neighborhoods * min;
        neighborhoods = distribute_add(neighborhoods, pop_to_be_filled);
        console.log("neighborhood populations before max is ");
        console.log(neighborhoods);
        // enforce max, check for leftovers.
        var leftover = 0;
        for (let i = 0; i < neighborhoods.length; i++) {
            if (neighborhoods[i] > max) {
                leftover += (neighborhoods[i] - max);
                neighborhoods[i] = max;
            }
        }
        //keep distributing leftover until it's 0 and everything is below max
        while (leftover > 0) {
            neighborhoods = distribute_add(neighborhoods, leftover);
            leftover = 0;
            for (let i = 0; i < neighborhoods.length; i++) {
                if (neighborhoods[i] > max) {
                    leftover += (neighborhoods[i] - max);
                    neighborhoods[i] = max;
                }
            }
            if (leftover === 1) {
                let random_index = Math.floor(Math.random() * neighborhoods.length);
                neighborhoods[random_index] += 1;
                leftover = 0;
            }
            console.log("leftover is " + leftover);
        }

        console.log("total population check:" +
            neighborhoods.reduce((a, b) => a + b, 0)
        );
        return neighborhoods;
    }
}

</script>
</body>
</html>