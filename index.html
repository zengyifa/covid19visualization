<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <head>
        <script src="https://d3js.org/d3.v3.min.js"></script>
        <script type="text/javascript" src="d3-grid.js"></script>
        <script type="text/javascript" src="util.js"></script>
        <script type="text/javascript" src="constants.js"></script>
        <script type="text/javascript" src="dropdown/dropdown.js"></script>
        <link rel="stylesheet" href="index.css">
        <link rel="stylesheet" href="dropdown/dropdown.css">

    </head>
    <title>Covid19 Visualization</title>
    <body>
        <div class="container">
            <div class="parameters">
                <div id="numDays">
                    Day Number: <span id="curDay">0</span>
                </div>
                <br />
                Initial infection rate <b>(<input type="number" style="font-weight: bold; font-size: medium; width: 22px;" id="initialInfectionRateValue"  min="0" max="10" value = 5.0>% people)</b>:
                0% <button class="smallButton" type="button" onclick="iMinus()">-</button><input id="initialInfectionRate" class="slider" type="range" min="0" max="10" step="0.1" value="5.0"> <button class="smallButton" type="button" onclick="iPlus()">+</button>10%
                <br />
                Current Cell Infection Rate <b>(<input type="number" style="font-weight: bold; font-size: medium; width: 17px;" id="curCellRateValue"  min="0" max="25" value = 10>%)</b>:
                0% <button class="smallButton" type="button" onclick="cMinus()">-</button><input id="curCellRate" class="slider" type="range"  min="0" max="25" value = 10> <button class="smallButton" type="button" onclick="cPlus()">+</button>25%
                <br/>
                Adjacent Cell Infection Rate <b>(<input type="number" style="font-weight: bold; font-size: medium; width: 17px;" id="adjCellRateValue"  min="0" max="25" value = 10>%)</b>:
                0% <button class="smallButton" type="button" onclick="aMinus()">-</button><input id="adjCellRate" class="slider" type="range"  min="0" max="25" value = 10> <button class="smallButton" type="button" onclick="aPlus()">+</button>25%
                <br/>
                Min Neighborhood Pop <b>(<input type="number" style="font-weight: bold; font-size: medium; width: 17px;" id="minValue" value = 10> people) </b>:
                10 <button class="smallButton" type="button" onclick="mnMinus()">-</button><input id="min" class="slider" type="range" min="10" value="10"><button class="smallButton" type="button" onclick="mnPlus()">+</button> <span id="minCeiling"></span>
                <br />
                Max Neighborhood Pop <b>(<input type="number" style="font-weight: bold; font-size: medium; width: 36px;" id="maxValue" value = 5000> people) </b>:
                <span id="maxFloor"></span> <button class="smallButton" type="button" onclick="nMinus()">-</button> <input id="max" type="range" max="5000"  value="5000" class="slider"> <button class="smallButton" type="button" onclick="nPlus()">+</button>5000
                <br/>
                Parkland Neighborhoods <b>(<input type="number" style="font-weight: bold; font-size: medium; width: 9px;" id="parklandValue" value = 0>%)</b>:
                0% <button class="smallButton" type="button" onclick="parkMinus()">-</button><input id="parkland" type="range" min="0" max="25" value="0" class="slider"><button class="smallButton" type="button" onclick="parkPlus()">+</button> 25%
                <br />
                Simulation Speed <b>(<input type="number" style="font-weight: bold; font-size: medium; width: 9px;" id="speedValue" value = 1> secs/day)</b> :
                1 <button class="smallButton" type="button" onclick="speedPlus()">+</button><input id="speed" class="slider" type="range" step = 0.1 min="0.1" max="1" value="1"><button class="smallButton" type="button" onclick="speedMinus()">-</button> 0.1
                <br /> 
                Population <b>(<input type="number" style="font-weight: bold; font-size: medium; width: 54px;" id="populationValue"  min="4000" max="400000" value = 100000> people)</b> :
                4000  <button class="smallButton" type="button" onclick="populationMinus()">-</button><input id="population" step="100" class="slider" type="range" min="4000" max="400000" value="100000">
                <button class="smallButton" type="button" onclick="populationPlus()">+</button> 400000
                <br />
                <div class="controls">
                    <button id="startButton" class="myButton" onclick="runSimulation()"><script>document.write(start_simulation_button_text)</script></button>
                    <br/>
                    <button id="nextDay" class="myButton" onclick="nextDay()">Next Day </button>
                    <br />
                    <div id="dropdown">
                        <button id="restart" onclick="dropdownFunction()" class="myButton">Restart Simulation</button>
                        <div id="myDropdown" class="dropdown-content">
                            <a onclick="restartOriginal()">From Original Initial State</a>
                            <a onclick="restartNew()">From New Initial State</a>
                        </div>
                    </div>
                </div> 
                <div class="display_variables">
                    <div>Total population:
                        <span id="populationDisplayed"> 100000 </span>
                    </div>
                    <div>
                        Number Infected: <span id="numInfected">0</span>
                    </div>
                </div>
            </div>
            <div class="vis"></div>
        </div>
    </body>
</head>
<body>

<script>


let population = parseInt(document.getElementById("population").value);
let parkland_percent = document.getElementById("parkland").value / 100;
let parklands = generateParklandsArray();
let num_parklands = parklands.filter(Boolean).length;
document.getElementById("parkland").oninput = function (){
    document.getElementById("parklandValue").value = this.value;
    resize.call(document.getElementById("parklandValue"))
}

document.getElementById("parklandValue").addEventListener("focusout", function(event) {
    if (this.value< 0 || this.value > 25 ){
        this.value = document.getElementById("parkland").value;
        this.style.width = ((this.value.length) * 9) + 'px';
        alert("Please enter a valid value for Parkland Neighborhoods.")
    }else {
        document.getElementById("parkland").value = this.value;
        parkland_percent = this.value / 100;
        parklands = generateParklandsArray();
        num_parklands = parklands.filter(Boolean).length;
        updateMinCeilingMaxFloor();
        neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
        updateRects();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
});

document.getElementById("parklandValue").addEventListener("keyup", resize);
/**
 * Updates the values when the increment buttons are clicked
 **/
function populationPlus(){
    document.getElementById("populationValue").value = parseInt(document.getElementById("populationValue").value) + 100;
    document.getElementById("population").value = parseInt(document.getElementById("population").value) + 100;
    document.getElementById("populationDisplayed").innerHTML = parseInt(document.getElementById("populationDisplayed").innerHTML) + 100;
    population = parseInt(population) + 100;
    resize.call(document.getElementById("populationValue"));
    updateMinCeilingMaxFloor();
    distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
    updatePoints();
}

function populationMinus(){
    document.getElementById("populationValue").value = parseInt(document.getElementById("populationValue").value) - 100;
    document.getElementById("population").value = parseInt(document.getElementById("population").value) - 100;
    document.getElementById("populationDisplayed").innerHTML = parseInt(document.getElementById("populationDisplayed").innerHTML) - 100;
    population = parseInt(population) - 100;
    resize.call(document.getElementById("populationValue"));
    updateMinCeilingMaxFloor();
    distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
    updatePoints();
}

function iPlus(){
    var newI =parseFloat(parseFloat(document.getElementById("initialInfectionRateValue").value).toFixed(1) - (-0.1)).toFixed(1) ;
    if ( newI< 0 || newI > 10){
        alert("Please enter a value between 0 and 10 for initial infection rate.")
    }else {
        document.getElementById("initialInfectionRate").value = newI;
        document.getElementById("initialInfectionRateValue").value = newI;
        resize.call(document.getElementById("initialInfectionRateValue"))
        updateMinCeilingMaxFloor();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
    
};

function iMinus(){
    var newI = parseFloat(parseFloat(document.getElementById("initialInfectionRateValue").value).toFixed(1) -0.1).toFixed(1);
    if ( newI< 0 || newI > 10){
        alert("Please enter a value between 0 and 10 for initial infection rate.")
    }else {
        document.getElementById("initialInfectionRate").value = newI;
        document.getElementById("initialInfectionRateValue").value = newI;
        resize.call(document.getElementById("initialInfectionRateValue"))
        updateMinCeilingMaxFloor();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
    
};

function cPlus(){
    var newA = parseInt(document.getElementById("curCellRateValue").value) + 1;
    if (newA< 0 || newA > 25){
        alert("Please enter a value between 0 and 25 for Current cell infectoin rate.")
    }else {
        document.getElementById("curCellRate").value = newA;
        document.getElementById("curCellRateValue").value = newA;
        cur_cell_rate =  1 + (document.getElementById("curCellRate").value / 100);
        resize.call(document.getElementById("curCellRateValue")) 
    }
};

function cMinus(){
    var newA = parseInt(document.getElementById("curCellRateValue").value) - 1;
    if (newA< 0 || newA > 25){
        alert("Please enter a value between 0 and 25 for Current cell infectoin rate.")
    }else {
        document.getElementById("curCellRate").value = newA;
        document.getElementById("curCellRateValue").value = newA;
        cur_cell_rate =  1 + (document.getElementById("curCellRate").value / 100);
        resize.call(document.getElementById("curCellRateValue")) 
    }
};

function aPlus(){
    var newA = parseInt(document.getElementById("adjCellRateValue").value) + 1;
    if (newA< 0 || newA > 25){
        alert("Please enter a value between 0 and 25 for Adjacent cell infectoin rate.")
    }else {
        document.getElementById("adjCellRate").value = newA;
        document.getElementById("adjCellRateValue").value = newA;
        adj_cell_rate =  1 + (document.getElementById("adjCellRate").value / 100);
        resize.call(document.getElementById("adjCellRateValue")) 
    }
};

function aMinus(){
    var newA = parseInt(document.getElementById("adjCellRateValue").value) - 1;
    if (newA< 0 || newA > 25){
        alert("Please enter a value between 0 and 25 for Adjacent cell infectoin rate.")
    }else {
        document.getElementById("adjCellRate").value = newA;
        document.getElementById("adjCellRateValue").value = newA;
        adj_cell_rate =  1 + (document.getElementById("adjCellRate").value / 100);
        resize.call(document.getElementById("adjCellRateValue")) 
    }
};

function mnPlus(){
    var newN = parseInt(document.getElementById("minValue").value) + 10;
    if (newN< parseInt(document.getElementById("min").min) || newN > parseInt(document.getElementById("min").max) ){
        alert("Please enter a valid value for Max Neighborhood Pop.")
    }else {
        document.getElementById("min").value = newN;
        document.getElementById("minValue").value = newN;
        neighborhood_min = parseInt(newN);
        resize.call(document.getElementById("minValue")) 
        neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
        updateRects();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
};


function mnMinus(){
    var newN = parseInt(document.getElementById("minValue").value) - 10;
    if (newN< parseInt(document.getElementById("min").min) || newN > parseInt(document.getElementById("min").max) ){
        alert("Please enter a valid value for Max Neighborhood Pop.")
    }else {
        document.getElementById("min").value = newN;
        document.getElementById("minValue").value = newN;
        neighborhood_min = parseInt(newN);
        resize.call(document.getElementById("minValue")) 
        neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
        updateRects();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
};

function nPlus(){
    var newN = parseInt(document.getElementById("maxValue").value) + 100;
    if (newN< parseInt(document.getElementById("max").min) || newN > parseInt(document.getElementById("max").max) ){
        alert("Please enter a valid value for Max Neighborhood Pop.")
    }else {
        document.getElementById("max").value = newN;
        document.getElementById("maxValue").value = newN;
        resize.call(document.getElementById("maxValue")) 
        neighborhood_max = parseInt(newN);
        neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
        updateRects();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
};


function nMinus(){
    var newN = parseInt(document.getElementById("maxValue").value) - 100;
    if (newN< parseInt(document.getElementById("max").min) || newN > parseInt(document.getElementById("max").max) ){
        alert("Please enter a valid value for Max Neighborhood Pop.")
    }else {
        document.getElementById("max").value = newN;
        document.getElementById("maxValue").value = newN;
        resize.call(document.getElementById("maxValue")) 
        neighborhood_max = parseInt(newN);
        neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
        updateRects();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
};


function parkPlus(){
    var newP = parseInt(document.getElementById("parklandValue").value) + 1;
    if (newP< 0 || newP > 25 ){
        alert("Please enter a valid value for Parkland Neighborhoods.")
    }else {
        document.getElementById("parkland").value = newP;
        document.getElementById("parklandValue").value = newP;
        parkland_percent = newP / 100;
        resize.call(document.getElementById("parklandValue"))    
        parklands = generateParklandsArray();                                       
        num_parklands = parklands.filter(Boolean).length;
        updateMinCeilingMaxFloor();
        neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
        updateRects();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
};

function parkMinus(){
    var newP = parseInt(document.getElementById("parklandValue").value) - 1;
    if (newP< 0 || newP > 25 ){
        alert("Please enter a valid value for Parkland Neighborhoods.")
    }else {
        document.getElementById("parkland").value = newP;
        document.getElementById("parklandValue").value = newP;
        parkland_percent = newP / 100;
        resize.call(document.getElementById("parklandValue"))
        parklands = generateParklandsArray();
        num_parklands = parklands.filter(Boolean).length;
        updateMinCeilingMaxFloor();
        neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
        updateRects();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
};

function speedPlus(){
    var newS = parseFloat(parseFloat(document.getElementById("speed").value).toFixed(1) - (-0.1)).toFixed(1);
    if (newS< 0.1 || newS > 1 ){
        alert("Please enter a valid value for Simulation Speed.")
    }else {
        document.getElementById("speed").value = newS;
        document.getElementById("speedValue").value = newS;
        resize.call(document.getElementById("speedValue"))
        simulation_speed = getSimulationSpeed(document.getElementById("speed").value);
        if (running === true) {
            clearInterval(tick);
            tick = setInterval(update, simulation_speed);
        }
    }
};

function speedMinus(){
    var newS = parseFloat(parseFloat(document.getElementById("speed").value).toFixed(1) - 0.1).toFixed(1);
    if (newS< 0.1 || newS > 1 ){
        alert("Please enter a valid value for Simulation Speed.")
    }else {
        document.getElementById("speed").value = newS;
        document.getElementById("speedValue").value = newS;
        resize.call(document.getElementById("speedValue"))
        simulation_speed = getSimulationSpeed(document.getElementById("speed").value);
        if (running === true) {
            clearInterval(tick);
            tick = setInterval(update, simulation_speed);
        }
    }
};


document.getElementById("parkland").onmouseup = function (){
    parkland_percent = this.value / 100;
    parklands = generateParklandsArray();
    num_parklands = parklands.filter(Boolean).length;
    updateMinCeilingMaxFloor();
    neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
    updateRects();
    distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
    updatePoints();
}

updateMinCeilingMaxFloor();
document.getElementById("population").oninput = function () {
    document.getElementById("populationValue").value = this.value;
    resize.call(document.getElementById("populationValue"));
    document.getElementById("populationDisplayed").innerHTML= this.value;
    population = this.value;
}

document.getElementById("population").onmouseup = function() {
    resize.call(document.getElementById("populationValue"));
    distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
    updateMinCeilingMaxFloor();
    updatePoints();
}


/**
 * Updates the simulation with the value inside the "populationValue" box when the user leaves the input box
 **/
document.getElementById("populationValue").addEventListener("focusout", function(event) {
    
    if (this.value< 4000 || this.value > 400000){
        this.value = population;
        this.style.width = ((this.value.length) * 9) + 'px';
        alert("Please enter a value between 4000 and 400000 for population.")
    }else {
        document.getElementById("population").value = this.value;
        document.getElementById("populationDisplayed").innerHTML= this.value;
        population = this.value;
        updateMinCeilingMaxFloor();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
    
});

document.getElementById("initialInfectionRateValue").addEventListener("focusout", function(event) {
    
    if (this.value< 0 || this.value > 10){
        this.value = population;
        this.style.width = ((this.value.length) * 9) + 'px';
        alert("Please enter a value between 0 and 10 for initial infection rate.")
    }else {
        document.getElementById("initialInfectionRate").value = this.value;
        updateMinCeilingMaxFloor();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
    
});
document.getElementById("populationValue").addEventListener("keyup", resize)

document.getElementById("initialInfectionRateValue").addEventListener("keyup", resize)

function resize() {
    this.style.width = ((this.value.length) * 9) + 'px';
}

function updateMinCeilingMaxFloor() {
    let minCeiling = Math.floor(document.getElementById("population").value / (num_neighborhoods - num_parklands));
    let maxFloor = Math.ceil(document.getElementById("population").value / (num_neighborhoods - num_parklands));
    document.getElementById("minCeiling").innerHTML = minCeiling;
    document.getElementById("maxFloor").innerHTML = maxFloor;
    document.getElementById("min").max = minCeiling;
    document.getElementById("max").min = maxFloor;
    document.getElementById("min").value = document.getElementById("min").min;
    document.getElementById("max").value = document.getElementById("max").max;
    var event = new Event('mouseup', {
        bubbles: true,
        cancelable: true,
    });
    document.getElementById("min").dispatchEvent(event);
    document.getElementById("max").dispatchEvent(event);
}

document.getElementById("minValue").value = document.getElementById("min").value ;
document.getElementById("maxValue").value = document.getElementById("max").value ;

//assuming num_neighborhoods is a perfect square
let neighborhood_min = parseInt(document.getElementById("min").value);
let neighborhood_max = parseInt(document.getElementById("max").value);

/**
 * returns a boolean array where true represents a parkland neighborhood.
 **/
function generateParklandsArray() {
    var result = Array(num_neighborhoods).fill(false);
    for (let i = 0; i < Math.ceil(parkland_percent * num_neighborhoods); i++) {
        var index = Math.floor(Math.random() * (num_neighborhoods - 1));
        while (result[index] === true) {
            index = Math.floor(Math.random() * (num_neighborhoods - 1));
        }
        result[index] = true;
    }
    return result;
}

let neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
document.getElementById("min").oninput = function() {
    document.getElementById("minValue").value = this.value;
    resize.call(document.getElementById("minValue"));
}

document.getElementById("min").onmouseup = function() {
    document.getElementById("minValue").value = this.value;
    neighborhood_min = parseInt(this.value);
    neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
    updateRects();
    distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
    updatePoints();
}

document.getElementById("min").ontouchend = function() {
    document.getElementById("minValue").value = this.value;
    neighborhood_min = parseInt(this.value);
    neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
    resize.call(document.getElementById("minValue"));
    updateRects();
    distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
    updatePoints();
}

document.getElementById("minValue").addEventListener("focusout", function(event) {
    if (this.value< parseInt(document.getElementById("min").min) || this.value > parseInt(document.getElementById("min").max) ){
        this.value = document.getElementById("min").value;
        this.style.width = ((this.value.length) * 9) + 'px';
        alert("Please enter a valid value for Min Neighborhood Pop.")
    }else {
        document.getElementById("min").value = this.value;
        neighborhood_min = parseInt(this.value);
        neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
        updateRects();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
});

document.getElementById("minValue").addEventListener("keyup", resize);

document.getElementById("max").oninput = function() {
    document.getElementById("maxValue").value = this.value ;
    resize.call(document.getElementById("maxValue"));
}

document.getElementById("max").onmouseup = function() {
    document.getElementById("maxValue").value = this.value ;
    neighborhood_max = parseInt(this.value);
    neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
    updateRects();
    distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
    updatePoints();
}

document.getElementById("max").ontouchend = function() {
    document.getElementById("maxValue").value = this.value ;
    neighborhood_max = parseInt(this.value);
    neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
    resize.call(document.getElementById("minValue"));
    updateRects();
    distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
    updatePoints();
}

document.getElementById("maxValue").addEventListener("focusout", function(event) {
    if (this.value< parseInt(document.getElementById("max").min) || this.value > parseInt(document.getElementById("max").max) ){
        this.value = document.getElementById("max").value;
        this.style.width = ((this.value.length) * 9) + 'px';
        alert("Please enter a valid value for Max Neighborhood Pop.")
    }else {
        document.getElementById("max").value = this.value;
        neighborhood_max = parseInt(this.value);
        neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
        updateRects();
        distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
        updatePoints();
    }
});

document.getElementById("maxValue").addEventListener("keyup", resize);

let cur_cell_rate = 1 + (document.getElementById("curCellRate").value / 100);
let adj_cell_rate = 1 + (document.getElementById("adjCellRate").value / 100);

var cur_infections = 0;
//represents the number of infections in each neighborhood
let neighborhood_infections = Array(num_neighborhoods).fill(0);
//represents a map from neighborhood number to number of infections, where each neighborhood has room for more infections.
let cur_infectionable = Object.assign({},neighborhood_infections);
distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);

var cur_days = 0;


var rects = [];


var rectGrid = d3.layout.grid()
    .bands()
    .size([gridSize, gridSize])
    .rows([rows_cols])
    .cols([rows_cols]);

var svg = d3.select(".vis").append("svg")
    .attr({
        width: width,
        height: height
    })
    .attr("class", "visualization")
    .attr("transform", "translate(70,70)");


for (let i = 0; i < neighborhood_infections.length; i++) {
    let radius = getRadiusFromInfected(neighborhood_infections[i]);
    addNeighborhood(neighborhood_populations[i],radius, parklands[i]);
}

document.getElementById("curCellRate").oninput = function() {
    document.getElementById("curCellRateValue").value = this.value;
    cur_cell_rate =  1 + (document.getElementById("curCellRate").value / 100);
    resize.call(document.getElementById("curCellRateValue"));
}

document.getElementById("curCellRateValue").addEventListener("focusout", function(event) {
    if (this.value< 0 || this.value > 25){
        this.value = document.getElementById("curCellRate").value;
        this.style.width = ((this.value.length) * 9) + 'px';
        alert("Please enter a value between 0 and 25 for current cell infectoin rate.")
    }else {
        document.getElementById("curCellRate").value = this.value;
        cur_cell_rate =  1 + (document.getElementById("curCellRate").value / 100);
        this.style.width = ((this.value.length) * 9) + 'px';
    }
});

document.getElementById("curCellRateValue").addEventListener("keyup", resize);

document.getElementById("adjCellRate").oninput = function() {
    document.getElementById("adjCellRateValue").value = this.value;
    adj_cell_rate =  1 + (document.getElementById("adjCellRate").value / 100);
    resize.call(document.getElementById("adjCellRateValue"));
}

document.getElementById("adjCellRateValue").addEventListener("focusout", function(event) {
    if (this.value< 0 || this.value > 25){
        this.value = document.getElementById("adjCellRate").value;
        this.style.width = ((this.value.length) * 9) + 'px';
        alert("Please enter a value between 0 and 25 for Adjacent cell infectoin rate.")
    }else {
        document.getElementById("adjCellRate").value = this.value;
        adj_cell_rate =  1 + (document.getElementById("adjCellRate").value / 100);
        this.style.width = ((this.value.length) * 9) + 'px';
    }
});

document.getElementById("adjCellRateValue").addEventListener("keyup", resize);

document.getElementById("initialInfectionRate").oninput = function() {
    document.getElementById("initialInfectionRateValue").value = this.value;
    resize.call(document.getElementById("initialInfectionRateValue"));
    document.getElementById("numInfected").innerHTML = Math.floor(this.value / 100 * parseInt(document.getElementById("population").innerHTML));
    
}

document.getElementById("initialInfectionRate").onmouseup = function() {
    distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
    resize.call(document.getElementById("initialInfectionRateValue"));
    updatePoints();
}
document.getElementById("initialInfectionRate").ontouchend = function() {
    distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
    resize.call(document.getElementById("initialInfectionRateValue"));
    updatePoints();
}

/**
 * calculates and distributes infections to clean neighborhoods
 **/
function distributeInitialInfections(infection_rate) {
    neighborhood_infections = Array(num_neighborhoods).fill(0);
    cur_infectionable = Object.assign({},neighborhood_infections);
    for (const i in cur_infectionable) {
        if (parklands[i] === true) {
            delete cur_infectionable[i];
        }
    }
    cur_infections = Math.floor(infection_rate * population);
    document.getElementById("numInfected").innerHTML = cur_infections;
    distribute_infections(cur_infections);
}
/**
 * Gets the corresponding grayscale color for a neighborhood population
 **/
function getColorForPopulation(population) {
    for (const scale of population_to_grayscale_color) {
        if (population >= scale["min"] && population <= scale["max"]) {
            return scale["color"];
        }
    }
}

function getRadiusFromInfected(num_infected) {
    for (const scale of infections_to_radius) {
        if (num_infected >= scale["min"] && num_infected <= scale["max"]) {
            return scale["radius"];
        }
    }
}
function addNeighborhood(population, radius, parkland) {
    rects.push({});
    var rectangles = svg.selectAll("g")
        .data(rectGrid(rects))
        .enter()
        .append("g");

    rectangles.append("rect")
        .attr("width", max_radius * 2)
        .attr("height", max_radius * 2)
        .attr("class", "rect")
        .attr("fill", parkland ? parkland_cell_color : getColorForPopulation(population))
        .attr("stroke", "black")
        .attr("stroke-opacity","0.5")
        .attr("transform", function (d) {
            return "translate(" + d.x + "," + d.y + ")";
        });

    rectangles.append("circle")
        .attr("class", "point")
        .attr("cx", function (d) { return d.x+(max_radius) ; })
        .attr("cy", function (d) { return d.y+(max_radius); })
        .attr("r", radius)
        .attr("fill", "red");
}

function updateRects() {
    var rect = svg.selectAll(".rect")
        .data(rectGrid(rects));
    rect.each(function (d, i) {
        var new_color = parklands[i] ? parkland_cell_color : getColorForPopulation(neighborhood_populations[i])
        d3.select(this).transition().attr("fill", new_color);
    })
}


/**
 * updates points according to infection numbers
 **/
function updatePoints() {
    var point = svg.selectAll(".point")
        .data(rectGrid(rects));
    point.each(function (d, i) {
        let new_radius = getRadiusFromInfected(neighborhood_infections[i]);
        d3.select(this).transition().attr("r", new_radius);
    })
}

/**
 * Distributes population to neighborhoods
 */
function distribute_population(min, max) {
    let numNonParkNeighborhoods = num_neighborhoods - num_parklands;
    if (min * numNonParkNeighborhoods > population) {
        throw new Error("minimum neighborhood population too high");
    } else if (max * numNonParkNeighborhoods  < population) {
        throw new Error("maximum neighborhood population too low");
    } else if (min > max) {
        throw new Error("min neighborhood population can't be greater than max");
    }
    //neighborhoods includes parkland neighborhoods
    var neighborhoods = Array(num_neighborhoods).fill(min);
    var pop_to_be_filled = population - num_neighborhoods * min;

    neighborhoods = distribute_add(neighborhoods, pop_to_be_filled);
    //represents non-full neighborhoods
    var cur_populable = Object.assign({}, neighborhoods);
    // enforce max, check for leftovers.
    var leftover = 0;
    for (const i in cur_populable) {
        //account for parklands first
        if (parklands[i] === true) {
            leftover += cur_populable[i];
            neighborhoods[i] = 0;
            delete cur_populable[i];
        } else if (cur_populable[i] >= max) {
            leftover += (cur_populable[i] - max);
            neighborhoods[i] = max;
            delete cur_populable[i];
        }
    }
    //keep distributing leftover until it's 0 and everything is below max
    while (leftover > 0) {
        cur_populable = distribute_add_dict(cur_populable, leftover);
        leftover = 0;
        for (var i in cur_populable) {
            neighborhoods[i] = cur_populable[i];
            if (cur_populable[i] >= max) {
                leftover += (cur_populable[i] - max);
                neighborhoods[i] = max;
                delete cur_populable[i];
            }
        }
        console.log("leftover is " + leftover);
    }

    console.log("total population check:" +
        neighborhoods.reduce((a, b) => a + b, 0)
    );
    return neighborhoods;
}

/**
 * distributes num_infections into neighborhood_infections array, based on each neighborhood's max population.
 * updates cur_infectionable to have only non-fully infected neighborhoods
 * @param num_infections
 */
function distribute_infections(num_infections){
    cur_infectionable = distribute_add_dict(cur_infectionable, num_infections);
    var leftover = 0;
    for (const i in cur_infectionable) {
        neighborhood_infections[i] = cur_infectionable[i];
        if (cur_infectionable[i] >= neighborhood_populations[i]) {
            leftover += (cur_infectionable[i] - neighborhood_populations[i]);
            neighborhood_infections[i] = neighborhood_populations[i];
            delete cur_infectionable[i];
        }
    }
    while (leftover > 0) {
        cur_infectionable = distribute_add_dict(cur_infectionable, leftover);
        leftover = 0;
        for (const i in cur_infectionable) {
            neighborhood_infections[i] = Number(cur_infectionable[i]);
            if (cur_infectionable[i] >= neighborhood_populations[i]) {
                leftover += (cur_infectionable[i] - neighborhood_populations[i]);
                neighborhood_infections[i] = neighborhood_populations[i];
                delete cur_infectionable[i];
            }
        }
    }
}

/**
 * Takes in simulation speed in days per second and converts to milliseconds per day.
 **/
function getSimulationSpeed(secs_per_day) {
    return 1000 * secs_per_day;
}

let simulation_speed = getSimulationSpeed(document.getElementById("speed").value);

var tick = 0;
var running = false;

document.getElementById("speed").oninput = function() {
    document.getElementById("speedValue").value = this.value;
    resize.call(document.getElementById("speedValue"))
    simulation_speed = getSimulationSpeed(document.getElementById("speed").value);
    if (running === true) {
        clearInterval(tick);
        tick = setInterval(update, simulation_speed);
    }
}

document.getElementById("speedValue").addEventListener("focusout", function(event) {
    if (this.value< 0.1 || this.value > 10 ){
        this.value = document.getElementById("speed").value;
        this.style.width = ((this.value.length) * 9) + 'px';
        alert("Please enter a valid value for Simulation Speed.")
    }else {
        document.getElementById("speed").value = this.value;
        resize.call(document.getElementById("speedValue"))
        simulation_speed = getSimulationSpeed(document.getElementById("speed").value);
        if (running === true) {
            clearInterval(tick);
            tick = setInterval(update, simulation_speed);
        }
    }
});

document.getElementById("speedValue").addEventListener("keyup", resize);

/**
 * When next day button is clicked
 **/
function nextDay() {
    if (cur_infections < population) {
        updateInfections();
        updatePoints();
        cur_days += 1;
        updateDisplayVariables();
    }
    if (cur_infections >= population) {
        document.getElementById("nextDay").disabled = true;
        endOfSimulation();
    }
}

let initial_state = {"neighborhood_populations": JSON.parse(JSON.stringify(neighborhood_populations)) , "neighborhood_infections": JSON.parse(JSON.stringify(neighborhood_infections)),
                    "curCellRate": document.getElementById("curCellRate").value, "adjCellRate": document.getElementById("adjCellRate").value, "parklands": JSON.parse(JSON.stringify(parklands)), "cur_infectionable": JSON.parse(JSON.stringify(cur_infectionable)),
                    "cur_infections": cur_infections};

//keeps track of whether simulation reached end state.
function runSimulation() {
    if (running === false) {
        //remember initial state to go back to
        if (cur_days === 0) {
            initial_state["neighborhood_populations"] = JSON.parse(JSON.stringify(neighborhood_populations));
            initial_state["neighborhood_infections"] = JSON.parse(JSON.stringify(neighborhood_infections));
            initial_state["curCellRate"] = document.getElementById("curCellRate").value;
            initial_state["adjCellRate"] = document.getElementById("adjCellRate").value;
            initial_state["parklands"] = JSON.parse(JSON.stringify(parklands));
            initial_state["cur_infectionable"] = JSON.parse(JSON.stringify(cur_infectionable));
            initial_state["cur_infections"] = cur_infections;
        }
        //resuming or starting the simulation
        running = true;
        document.getElementById("startButton").innerHTML = pause_simulation_button_text;
        disableControls();
        tick = setInterval(update, simulation_speed);
    } else {
        //pausing logic
        clearInterval(tick);
        running = false;
        document.getElementById("nextDay").disabled = false;
        document.getElementById("startButton").innerHTML = continue_simulation_button_text;
        document.getElementById("restart").disabled = false;
    }
}

function update() {
    //check if everyone has been infected
    if (cur_infections >= population) {
        endOfSimulation();
        return;
    }
    updateInfections();
    updatePoints();
    cur_days += 1;
    updateDisplayVariables();
}
/**
 * increases a neighborhood's infections based on adjacent infections and current neighborhood infections
 * @param index the index of the neighborhood in a one dimensional array
 * */
function getUpdatedNeighborhoodInfections(index) {
   let row = getRow(index, rows_cols);
   let col = getCol(index, rows_cols);
   let adjIndices = getAdjacentsIndices(row, col, rows_cols);
   var updated_infections = Math.ceil(cur_cell_rate * neighborhood_infections[index]);
   for (const adj of adjIndices) {
       var percentage_adjacent = adj_cell_rate - 1;
       updated_infections = updated_infections +  Math.ceil(percentage_adjacent * neighborhood_infections[adj]);
   }
   return updated_infections;
}
/**
 *  Updates infections for the entire grid. Updates state variables as needed
 **/
function updateInfections() {
    for (let i = 0; i < neighborhood_infections.length; i++) {
        if (neighborhood_infections[i] < neighborhood_populations[i] && !parklands[i]) {
            let updated_num_infections = Math.min(neighborhood_populations[i], getUpdatedNeighborhoodInfections(i));
            cur_infections = cur_infections + (updated_num_infections - neighborhood_infections[i]);
            neighborhood_infections[i] = updated_num_infections;
        }
    }
}

function updateDisplayVariables() {
    document.getElementById("curDay").innerHTML = cur_days;
    document.getElementById("numInfected").innerHTML = cur_infections;
}
/**
 * Happens at the end of the simulation
 */
function endOfSimulation() {
    clearInterval(tick);
    running = false;
    document.getElementById("startButton").innerHTML = start_simulation_button_text;
    document.getElementById("startButton").disabled = true;
    document.getElementById("restart").disabled = false;
    if (cur_infections < population) {
        document.getElementById("nextDay").disabled = false;
    }
}
function enableControls() {
    document.getElementById("initialInfectionRate").disabled = false;
    document.getElementById("initialInfectionRateValue").disabled = false;
    document.getElementById("min").disabled = false;
    document.getElementById("max").disabled = false;
    document.getElementById("minValue").disabled = false;
    document.getElementById("maxValue").disabled = false;
    document.getElementById("nextDay").disabled = false;
    document.getElementById("population").disabled = false;
    document.getElementById("parkland").disabled = false;
    document.getElementById("parklandValue").disabled = false;
    document.getElementById("populationValue").disabled = false;
    var buttonList = document.getElementsByClassName("smallButton");
    for (var i =0; i< buttonList.length; i++) {
        buttonList[i].disabled = false;
    }
    document.getElementById("restart").disabled = false;
    document.getElementById("startButton").disabled = false;
}

/**
 * disables controls that shouldn't be changed when simulation is running
 */
function disableControls() {
    document.getElementById("initialInfectionRate").disabled = true;
    document.getElementById("initialInfectionRateValue").disabled = true;
    document.getElementById("min").disabled = true;
    document.getElementById("max").disabled = true;
    document.getElementById("minValue").disabled = true;
    document.getElementById("maxValue").disabled = true;
    document.getElementById("nextDay").disabled = true;
    document.getElementById("population").disabled = true;
    document.getElementById("parkland").disabled = true;
    document.getElementById("parklandValue").disabled = true;
    document.getElementById("populationValue").disabled = true;
    var buttonList = document.getElementsByClassName("smallButton");
    for (var i =0; i< buttonList.length; i++) {
        buttonList[i].disabled = true;
    }
    document.getElementById("restart").disabled = true;
}

/**
 * Restarts simulation in a new randomly distributed state based on current parameters
 */
function restartNew() {
    endOfSimulation();
    parklands = generateParklandsArray();
    neighborhood_populations = distribute_population(neighborhood_min, neighborhood_max);
    updateRects();
    distributeInitialInfections((document.getElementById("initialInfectionRate").value) / 100);
    updatePoints();
    enableControls();
    cur_days = 0;
    updateDisplayVariables();
}

/**
 * Restarts simulation in with starting point at t=0 for the current simulation, with identical distribution of infections, population,
 * parklands.
 */
function restartOriginal() {
    endOfSimulation();
    parklands = initial_state["parklands"];
    neighborhood_populations = initial_state["neighborhood_populations"];
    neighborhood_infections = initial_state["neighborhood_infections"];
    cur_infectionable = initial_state["cur_infectionable"];
    cur_infections = initial_state["cur_infections"];
    document.getElementById("curCellRate").value = initial_state["curCellRate"];
    document.getElementById("adjCellRate").value = initial_state["adjCellRate"];
    var event = new Event('input', {
        bubbles: true,
        cancelable: true,
    });
    document.getElementById("curCellRate").dispatchEvent(event);
    document.getElementById("adjCellRate").dispatchEvent(event);

    updatePoints();
    updateRects();
    enableControls();
    cur_days = 0;
    updateDisplayVariables();
}
</script>
</body>
</html>