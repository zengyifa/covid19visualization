<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <head>
        <script src="https://d3js.org/d3.v3.min.js"></script>
        <script type="text/javascript" src="d3-grid.js"></script>
    </head>
    <title>Covid19 Visualization</title>
    <body>
    <label for="rate">Infection Rate (between 0% to 100 %)</label>
    <input type="text" id="rate">
    <br/>
    <button onclick="startSimulation()">Start Simulation</button>
    </body>
</head>
<body>

<script>

function startSimulation() {
    var percent_rate = document.getElementById("rate").value;
    let infection_rate = 1 + (percent_rate / 100)
    console.log("infection rate is " + infection_rate);
    let max_radius = 50;
    let population = 100000;
    let initial_infection_rate = 0.01
    var cur_infections = Math.floor(initial_infection_rate * population);
    console.log("initial number of infections is " + cur_infections)
    //assuming num_neighborhoods is a perfect square
    let num_neighborhoods = 400;
    let neighborhood_populations = distribute_population(10, 400);
    let rows_cols = Math.sqrt(num_neighborhoods);

    //represents the number of infections in each neighborhood
    let neighborhood_infections = Array(num_neighborhoods).fill(0);
    //represents the neighborhoods that aren't fully infected yet
    let cur_infectionable = Object.assign({},neighborhood_infections);
    for (var i in cur_infectionable) {
        if (cur_infectionable[i] === neighborhood_populations[i]) {
            delete cur_infectionable[i];
        }
    }
    distribute_infections(cur_infections);
    //initialize infections in neighborhoods

    console.log(neighborhood_infections);
    var points = [];

    //dimensions of the grid, assumed to be a square.
    var gridSize = rows_cols * max_radius;
    //grid dimensions
    var pointGrid = d3.layout.grid()
        .points()
        .size([gridSize, gridSize])
        .rows([rows_cols])
        .cols([rows_cols]);

    //svg dimensions
    var width = gridSize * 2,
        height = gridSize * 2;
    var svg = d3.select("body").append("svg")
        .attr({
            width: width,
            height: height
        })
        .append("g")
        .attr("transform", "translate(70,70)");
    //10 by 10 grid means 100 points
    //start off with 100 points
    for (var i = 0; i < neighborhood_infections.length; i++) {
        var radius = neighborhood_infections[i] / neighborhood_populations[i] * max_radius;
        addPoint(radius);
    }


    var tick = setInterval(update, 100);


    function addPoint(radius) {
        points.push({});
        var point = svg.selectAll(".point")
            .data(pointGrid(points));
        point.enter().append("circle")
            .attr("class", "point")
            .attr("r", radius)
            .attr("transform", function (d) {
                return "translate(" + d.x + "," + d.y + ")";
            });

    }

    function update() {
        //check if everyone has been infected
        if (cur_infections >= population) {
            console.log("cur infections is " + cur_infections + " and has exceeded population");
            clearInterval(tick);
            return;
        }
        let num_new_infections = Math.min(population - cur_infections, Math.floor(infection_rate * cur_infections - cur_infections));
        // console.log("num new infections is " + num_new_infections)
        // //update current number of infections
        // console.log("cur infections was " + cur_infections);
        cur_infections = cur_infections + num_new_infections;
        console.log("num new infections is " + num_new_infections);
        console.log("cur infections is " + cur_infections);
        // console.log("cur infections is now " + cur_infections);
        //adjust number of infections to be distributed to be the amount needed to get to the population
        distribute_infections(num_new_infections);
        //make this select some
        var point = svg.selectAll(".point")
            .data(pointGrid(points));

        point.each(function (d, i) {
            // console.log("neighborhood infections at " + i + " is " + neighborhood_infections[i]);
            // console.log("neighborhood population at " + i + " is " + neighborhood_populations[i]);
            var new_radius = Math.min(max_radius, (neighborhood_infections[i] / neighborhood_populations[i]) * max_radius);
            d3.select(this).transition().attr("r", new_radius);
        })

    }

    /**
     * distributes value into array of length length
     * @param value to distribute
     * @return array of length length with randomly distributed value
     */
    function distribute(length, value) {
        if (length <= 1)
            return [value];
        var half = Math.floor(length / 2),
            dist = Math.floor(Math.random() * value);
        return distribute(half, dist).concat(distribute(length-half, value-dist));
    }

    /**
     * distributes value to array
     */
    function distribute_add(array, value) {
        var to_be_added = distribute(array.length, value);
        return array.map(function (num, idx) {
            return num + to_be_added[idx];
        });
    }

    /**
     * distributes value to values in dictionary
     */
    function distribute_add_dict(dict, value) {
        var to_be_added = distribute(Object.keys(dict).length, value);
        var arrayIndex = 0;
        console.log("to be added is ")
        console.log(to_be_added);
        console.log("dict is ")
        console.log(dict);
        for (var dictKey in dict) {
            dict[dictKey] += to_be_added[arrayIndex];
            arrayIndex += 1;
        }
        console.log("dict after addd is ");
        console.log(dict);
        return dict;
    }

    /**
     * Distributes population to neighborhoods
     */
    function distribute_population(min, max) {
        if (min * num_neighborhoods > population) {
            throw new Error("minimum neighborhood population too high");
        } else if (max * num_neighborhoods < population) {
            throw new Error("maximum neighborhood population too low");
        } else if (min > max) {
            throw new Error("min neighborhood population can't be greater than max");
        }
        var neighborhoods = Array(num_neighborhoods).fill(min);
        var pop_to_be_filled = population - num_neighborhoods * min;
        neighborhoods = distribute_add(neighborhoods, pop_to_be_filled);
        // enforce max, check for leftovers.
        var leftover = 0;
        for (let i = 0; i < neighborhoods.length; i++) {
            if (neighborhoods[i] > max) {
                leftover += (neighborhoods[i] - max);
                neighborhoods[i] = max;
            }
        }
        //keep distributing leftover until it's 0 and everything is below max
        while (leftover > 0) {
            neighborhoods = distribute_add(neighborhoods, leftover);
            leftover = 0;
            for (let i = 0; i < neighborhoods.length; i++) {
                if (neighborhoods[i] > max) {
                    leftover += (neighborhoods[i] - max);
                    neighborhoods[i] = max;
                }
            }
            if (leftover === 1) {
                let random_index = Math.floor(Math.random() * neighborhoods.length);
                //search for a non-maxed neighborhood
                while (neighborhoods[random_index] === max) {
                    random_index = Math.floor(Math.random() * neighborhoods.length);
                }
                neighborhoods[random_index] += 1;
                leftover = 0;
            }
            console.log("leftover is " + leftover);
        }

        console.log("total population check:" +
            neighborhoods.reduce((a, b) => a + b, 0)
        );
        return neighborhoods;
    }

    /**
     * distributes num_infections into neighborhood_infections array
     * @param num_infections
     */
    function distribute_infections(num_infections){
        cur_infectionable = distribute_add_dict(cur_infectionable, num_infections);
        console.log("cur_infectionable at beginning is ");
        console.log(cur_infectionable);
        var leftover = 0;
        for (var i in cur_infectionable) {
            neighborhood_infections[i] = cur_infectionable[i];
            // console.log("cur_infectionable at " + i  + " is  " + cur_infectionable[i]);
            // console.log("set neighborhood " + i + " to have infections " + neighborhood_infections[i]);
            if (cur_infectionable[i] >= neighborhood_populations[i]) {
                leftover += (cur_infectionable[i] - neighborhood_populations[i]);
                neighborhood_infections[i] = neighborhood_populations[i];
                delete cur_infectionable[i];
            }
        }
        console.log("neighborhood_infections at beginning is " );
        console.log(neighborhood_infections);
        console.log("after first distribution, leftover is " + leftover);
        while (leftover > 0) {
            cur_infectionable = distribute_add_dict(cur_infectionable, leftover);

            leftover = 0;
            for (var i in cur_infectionable) {
                neighborhood_infections[i] = Number(cur_infectionable[i]);
                if (cur_infectionable[i] >= neighborhood_populations[i]) {
                    leftover += (cur_infectionable[i] - neighborhood_populations[i]);
                    neighborhood_infections[i] = neighborhood_populations[i];
                    console.log("deleting neighborhood " + i);
                    delete cur_infectionable[i];
                }
            }
            console.log("cur_infectionable is " );
            console.log(cur_infectionable);
            console.log("neighborhood infections is ");
            console.log(neighborhood_infections);
            if (leftover === 1) {
                let random_index = Math.floor(Math.random() * neighborhood_infections.length);
                //search for a non-maxed neighborhood
                while (neighborhood_infections[random_index] === neighborhood_populations[random_index]) {
                    console.log("finding random index");
                    random_index = Math.floor(Math.random() * neighborhood_infections.length);
                }
                neighborhood_infections[random_index] += 1;
                leftover = 0;
            }
            console.log("leftover is " + leftover);
        }
    }
}

</script>
</body>
</html>